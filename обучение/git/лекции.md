# git
это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте

# Создание репозитория
## создание репозитория
для создания репозитория можно использовать комманду
`git init`
при этом необходимо находится в каталоге с проектом иначе папка будет создана в корневом каталоге

## добавление файлов
по умолчанию коммиты добавляются в ветку мастер.
добавление файлов происходит командой
`git add название файла и путь`
при этом файл индексируется и становится в ожидание. Для добавдения его в *git* необходимо создать первый коммит. после чего файл будет отображаться в `git show` а история его изменения в `git log`

# Коммиты в git

Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей. Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом! для простоты будем считать их полными снимками проекта. 
`git commit `
при этом откроется текстовый редактор для добавления информации о комите.
Можно использовать команду
`git commit -m "описание коммита"`
тогда название коммиту будет присвоено сразу
# Ветвление в git

## создание ветки
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.
Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его родителей.
`git branch name`
## удаление ветки
Для удаления ветки выполните команду `git branch` с параметром `-d`:
```console
$ git branch -d name
Deleted branch name ( ).
```

## Перемещение ветки (branch forcing)


Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f`. Например, команда:

`git branch -f main HEAD~3`

Переместит (принудительно) ветку `main` на три родителя назад от `HEAD`. или вместо `HEAD` необходимо указать название ветки
# Ветки и слияния

Мы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими. 
## **Первый способ**
объединения изменений, который мы рассмотрим - это `git merge` - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами. 

## Второй способ Git Rebase
Второй способ объединения изменений в ветках - это _rebasing_. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место. Несмотря на то, что это звучит достаточно непонятно, преимущество `rebase` в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете `rebase`.
`git rebase main`
# Перемещение по  веткам Git (относительные ссылки)
для перемещения по веткам и коммитам необходимо использовать знаки 
git checkout main ^ для перемещения на один вверх по указанной ветке или ~num(4) для перемещения на несколько коммитов вверх.
```
git checkout HEAD~4
```
# Отмена изменений в Git

Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: первый - это `git reset`, а второй - `git revert`. Попробуем оба на следующем шаге.

## Git reset
`git reset` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; `git reset` перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
`Git reset HEAD~1`

## Git revert
Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.
Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать `git revert`
`git revert HEAD`
# Git cherry-pick
Первая из таких команд - это `git cherry-pick`. Она выглядит вот так:
 `git cherry-pick <Commit1> <Commit2> <...>`
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`). 
# Git Interactive Rebase

Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши) Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.
Всё, что нужно для интерактивного rebase - это опция `-i`
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор. После открытия окна интерактивного rebase есть три варианта для каждого коммита:
- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть `pick` - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.
`Git rebase -i HEAD~4`
